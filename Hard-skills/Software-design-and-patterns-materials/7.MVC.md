# 1.	INTRODUCTION
  This lecture discusses existing MV patterns classified in three main families:
  - Model-View-Controller (MVC),
  - Model-View-View Model (MVVM),
  - Model-View-Presenter (MVP). 

# 1.1.	GOOD ARCHITECTURE VS DESIGN SMELLS
  Основываясь на опыте тысяч разработчиков и проектов, мы можем сказать, что хорошая архитектура имеет следующие характеристики:
    • Эффективность: все функции должны работать должным образом и правильно обрабатывать ошибки.
    • Гибкость: способность программного обеспечения легко изменяться в соответствии с различными требованиями пользователя и системы.
    • Расширяемость: возможность легко добавлять новые функции без необходимости обновлять многие другие части приложения.
    • Масштабируемость процесса разработки: увеличение количества разработчиков не требует изменения дизайна.
    • Тестируемость: модули вашего приложения должны легко тестироваться.
    • Возможность повторного использования: в вашем коде нет дубликатов.
    • Ремонтопригодность: хорошо структурированный, читаемый и понятный код. Ремонтопригодность.

# 1.2.	WHY DO WE NEED STRUCTURAL MV* PATTERS?
  Несмотря на все эти характеристики, главное в архитектуре зданий - снижение сложности. А для уменьшения сложности пока не изобретено ничего, кроме разделения на части. Иногда это называют принципом «разделяй и властвуй», но по сути это иерархическая декомпозиция.

  «Хотя шаблоны MV * имеют довольно много различий между собой, их цели схожи: отделить код пользовательского интерфейса (представление) от кода логики (презентатор, контроллер, модель представления и т. Д.) И кода обработки данных (модель). Это позволяет каждая из частей этого шаблона должна быть разработана независимо. Например, вы можете изменить внешний вид и стиль своего приложения, не затрагивая бизнес-логику и данные.

# 2.	MVC
  MVC - это первый паттерн, который мы рассмотрим. MVC отделяет представление домена приложения (Модель) от отображения состояния приложения (Представление) и управления взаимодействием с пользователем (Контроллер). Каждый из этих компонентов предназначен для обработки некоторых аспектов вашего приложения. **Модель** несет ответственность за обработку ваших данных и работу с ними. Вот где должна идти бизнес-логика вашего приложения. **Представление** - это то, что ваши пользователи видят и с чем взаимодействуют. И последнее, но не менее важное: **контроллер** - это часть, которая заставляет представление и модель взаимодействовать друг с другом. Разделение вашего приложения на эти три части позволяет вам повторно использовать их или легко заменять, не меняя другие части.

# 2.1.	PASSIVE/ACTIVE MODEL
  Схемы MVC можно разделить на два типа: пассивное и активное представление. Ваше представление должно получать данные из модели, и это может быть достигнуто двумя способами.
  1. В первом случае view знает о модели и получает данные напрямую от нее. 
  2. Во втором случае данные из модели предоставляются контроллером, поэтому view ничего не знает о модели, что делает ее более модульной. 

  Может быть несколько представлений - они могут отображать одни и те же данные по-разному, или они могут отвечать за отображение разных частей данных из Модели. Контроллер является наиболее спорным компонентом, потому что он может выполнять различные функции, такие как обработка событий представления или отвечать за передачу данных между представлением и моделью. Тем не менее, обычно Контроллер всегда знает о Модели и может изменить ее (обычно в результате действий пользователя). Он также может управлять представлениями / представлениями (особенно если их несколько) и, соответственно, знать о представлениях, но в этом нет необходимости.
  Модель, как и представление, также может быть пассивной или активной. Пассивная модель не влияет ни на представление, ни на контроллер. В этом случае все изменения в модели отслеживаются контроллером, и он также отвечает за перерисовку представления, когда это необходимо.  

  Но обычно под MVC подразумевают вариант с активной моделью. «Активная модель» сообщает, что в ней произошли изменения. Причем делает это через шаблон Observer, рассылая уведомления об изменениях всем своим «подписчикам». «Active View» сам подписывается на эти сообщения и, таким образом, знает, когда повторно считывать данные, которые ему нужны, из модели и обновлять себя. В случае пассивного просмотра подписчиком является контроллер, который затем обновляет представление. Шаблон наблюдателя позволяет модели, с одной стороны, информировать представление или контроллер о том, что в нем произошли изменения, а с другой стороны, фактически ничего о них «не знать» (за исключением того, что они реализуют некий указанный «абонентский» интерфейс) и, таким образом, остаются независимыми. Это называется слабой связью и считается вторым ключевым моментом MVC.

# 2.2.	USER INTERACTION WITH THE VIEW
# 2.3.	MVC IN WEB
  MVC обычно используется в веб-разработке. В контексте этого можно сказать, что Модель может быть представлена базой данных. Ваш веб-сервер, который интерпретируется как Контроллер. Иногда также говорят, что контроллер является центром обработки всех запросов и принятия решений, а также промежуточным уровнем, который обеспечивает связь между моделью и представлением. Просмотр - это пользовательский интерфейс. Причем интерфейс в данном случае, как правило, понимается исключительно как «дизайн», просто набор графических элементов.

  # 2.3.1.	Model 
    Модель отвечает за получение данных и манипулирование ими, поэтому это мозг приложения. Обычно он взаимодействует с какой-то базой данных. Это может быть реляционная база данных, такая как MySQL, или база данных NoSQL, такая как MongoDB. На самом деле это не имеет значения, и во многих фреймворках, поддерживающих несколько баз данных, код модели останется неизменным.
    
    Необходимо изменить только драйвер базы данных, и это даже не обязательно должна быть база данных, которая с ним работает. Это может быть простой файл. Итак, вы можете просто заставить свою модель взаимодействовать с файлом JSON и извлекать данные из этого файла.  

  # 2.3.2.	View
    Затем у нас есть представление, и вы можете догадаться, о чем он заботится. Это реальный вид приложения, так что это пользовательский интерфейс, это то, что видит пользователь и как он взаимодействует с приложением.

    Итак, в сети представление обычно состоит из HTML и CSS вместе с динамическими значениями из контроллера. Итак, контроллер взаимодействует с представлением так же, как и с моделью. Теперь, в зависимости от того, какой фреймворк вы используете, механизм шаблонов может отличаться.

    Механизм шаблонов - это то, что позволяет получать динамические данные. Если у нас есть прямой HTML, мы не можем выводить переменные, мы не можем использовать логику, выбирать оператор if и т. Д., Но с механизмами шаблонов мы можем делать это прямо в представлении или прямо в шаблоне.
    
  # 2.3.3.	Controller
    Итак, наконец, у нас есть контроллер, и контроллер принимает пользовательский ввод, так что это может быть от пользователя, посещающего страницу или щелчка по ссылке, которая делает запрос на получение, или отправки формы, которая делает почтовый запрос, а также у нас есть запросы на удаление. или ставьте запросы на обновление. И это нельзя сделать прямо из браузера, вы можете только получить или опубликовать, но у нас есть HTTP-клиенты, которые иногда встроены в структуру, которые могут это делать.

    Теперь контроллер действует как своего рода агент между моделью и представлением. Контроллер попросит модель получить некоторые данные из базы данных, а затем контроллер возьмет эти данные, загрузит представление и передаст в него эти данные. Затем механизм шаблонов вступает во владение и может выполнять некоторую логику, выходные переменные и тому подобное.

    Контроллер также может загружать представление, не передавая ему данные, так что это просто обычная веб-страница с HTML и CSS, без фактической логики шаблонов.

# 2.4.	MVC IN ARCHITECTURE    
  Понимание MVC из предыдущего раздела может работать, но это не совсем правильно, потому что:
    • Независимость модели является центральным элементом MVC. Если Модель тонкая, то есть содержит только данные, то возможность ее самостоятельного развития не имеет большого смысла. Соответственно, при таком подходе сам MVC теряет смысл.
    
    • Вся бизнес-логика приложения, то есть большая часть кода, сосредоточена в Контроллере, и это несмотря на то, что Контроллер является наиболее зависимой частью в MVC - в общем, это зависит как от Модели, так и от вид. В хорошо спроектированных приложениях стараются делать прямо противоположное - наиболее зависимые части должны быть минимальными, а не максимальными.
    
    • Поскольку, как правило, не только модель тонкая, но и представление тонкое (Dumb GUI, Dumb View), то в результате, помимо всей бизнес-логики приложения, контроллер также размещает логика управления пользовательским интерфейсом. То есть вместо разделения бизнес-логики и логики представления этот подход приводит к их смешению.  

  Итак, MVC лучше брать не как шаблон, а как набор архитектурных принципов и идей, используемых при построении пользовательских информационных систем (обычно сложных). Суть таких принципов заключается в следующем: сложная система должна быть разделена на модули. Более того, рекомендуется проводить декомпозицию иерархически, и модули, на которые делится система, должны быть, если возможно, независимыми или слабосвязанными (низкая связь).

  **Basically, MVC is based on three simple ideas:**
    • Разделите модель и пользовательский интерфейс(UI) на модули.  
    • Разделение модели и пользовательского интерфейса. Независимые модели и пользовательский интерфейс синхронизируются с помощью шаблона Observer. Это позволяет модели быть независимой и ничего не знать о своих подписчиках.
    • Разделить пользовательский интерфейс на представление и контроллер.

# 2.5.	ORIGINAL REENSKAUG’S SCHEME (ОРИГИНАЛЬНАЯ СХЕМА РЕЕНСКАУГА)
    В общем, является ли Модель одним объектом или несколькими объектами? И действительно ли модель в «схеме MVC» такая же, как модель предметной области, которая описывает предметную область и бизнес-логику приложения? Когда было сказано, что система должна быть разделена на модули, которые слабо связаны друг с другом, мы не упомянули главное правило - модули должны взаимодействовать друг с другом только на уровне абстрактных интерфейсов (Dependency Inversion Principle). Интерфейс модуля обычно реализуется специальным объектом - Фасадом. Таким образом, ключевая идея MVC действительно состоит в том, что пользовательское приложение разделено на два модуля - один из которых моделирует домен и реализует бизнес-логику (модель предметной области), а второй отвечает за взаимодействие с пользователем (пользовательский интерфейс). Но в то же время Модель в «схеме MVC» вовсе не идентична модели предметной области (которая может быть сколь угодно сложной и состоять из множества объектов), а является лишь ее интерфейсом и фасадом.

# 2.6.	DOMAIN MODEL FACADE. PROVIDER DICTATES INTERFACE (ДОМЕННАЯ МОДЕЛЬ ФАСАД. ПРОВАЙДЕР ДИКТИРУЕТ ИНТЕРФЕЙС)
  Традиционно в клиент-серверных приложениях сервер считается основным. Он оказывает услуги и решает, в каком виде это должно быть реализовано. Итак, интерфейс и фасад обычно определяются с точки зрения сервера. И клиенты адаптируются к этому указанному формату.
 
  На практике более адекватна не серверная архитектура, а клиент-ориентированная. Подход, ориентированный на клиента, намного лучше подходит для принципа разделения интерфейсов, поскольку он использует множество тонких требуемых интерфейсов вместо одного толстого предоставляемого интерфейса.  
  
  Из-за того, что фасад, присутствующий в исходном MVC, был «утерян», его роль часто берет на себя Контроллер. Это источник идеи о том, что контроллер находится «между моделью и представлением», служит связующим звеном между ними и предоставляет данные, необходимые для представления.  

# 2.7.	HOW TO APPLY
# 2.8.	SUMMARY
  Итак, какие преимущества дает нам MVC?

  • Во-первых, это более простое общее обслуживание. Когда в приложение необходимо внести обновления, ясно, являются ли изменения ориентированными на данные, то есть изменениями в моделях и контроллерах, или просто визуальными, то есть изменениями в представлениях.

  • Разделение моделей и представлений означает, что писать модульные тесты для бизнес-логики значительно проще.
  
  • Дублирование низкоуровневой модели и кода контроллера (то есть того, что мы могли использовать вместо этого) устранено во всем приложении.
  
  • В зависимости от размера приложения и разделения ролей эта модульность позволяет разработчикам, отвечающим за базовую логику, и разработчикам, работающим над пользовательскими интерфейсами, работать параллельно.

  Сегодняшние среды разработки прошли долгий путь защиты разработчиков от таких сложностей, делая ненужным разделение между вводом и выводом устройства на уровне приложения. Во многих средах разработки исходные цели шаблона модель-представление-контроллер могут быть реализованы сегодня путем простого отделения форм приложения и связанных элементов управления от его модели предметной области.

# 3.	MVP
  MVP (Model-View-Presenter) - это продукт эволюции MVC. В ранее описанном шаблоне View отвечает только за отображение данных, а Controller обрабатывает все взаимодействия и события View. Во время разработки Web у нас есть некоторые элементы, которые могут самостоятельно обрабатывать события и ввод данных пользователем. Теперь контроллеру не нужно отвечать за обработку этих операций, и здесь у нас есть Presenter. Фактически, MVP - это более современный способ создания приложений с пользовательскими интерфейсами.

# 3.1.	P FOR PRESENTER
  Фактически, Presenter - это компонент бизнес-логики для представления. В отличие от MVC, вызовы из представления делегируются презентатору, который отделен от представления и взаимодействует с ним через интерфейс.
 
  В MVP есть три компонента:
  • Модель. Это данные вашего приложения, логика их получения и хранения. Часто он основан на базе данных или на результатах веб-сервисов. В некоторых случаях вам потребуется адаптировать, изменить или расширить его, прежде чем использовать в View.
  
  •	Вид. Обычно это форма с виджетами. События View должны быть отправлены ведущему.
  
  •	Ведущий. Презентатор содержит всю логику пользовательского интерфейса и отвечает за синхронизацию модели и представления. Когда представление уведомляет докладчика о том, что пользователь взаимодействует с системой (например, нажимает кнопку), докладчик решает обновить модель и синхронизирует все изменения между моделью и представлением.  

# 3.2.	PASSIVE VIEW
  Есть два типа этого шаблона: пассивный просмотр и контролирующий контроллер(Passive View and Supervising Controller.).
  
  В варианте MVP с пассивным представлением представление ничего не знает о модели, но вместо этого предоставляет простые свойства для всей информации, которая должна отображаться на экране. Докладчик будет читать информацию из модели и обновлять свойства в представлении.

  Модели могут запускать события; Докладчики могут подписаться на них, если они хотят обновить представление. В этой пассивной архитектуре у нас нет концепции прямой привязки данных. Представления предоставляют установщики, которые презентаторы могут использовать для установки данных. 

  Преимущество этого изменения по сравнению с MVC состоит в том, что оно улучшает тестируемость нашего приложения и обеспечивает более четкое разделение между представлением и моделью.
  Хотя типичная реализация пассивного представления включает реализацию интерфейса с установщиками и получателями, существуют варианты, которые включают использование событий, которые могут отвязать представление докладчика. 

# 3.3.	SUPERVISING CONTROLLER
  В этом варианте MVP представление знает о модели и отвечает за привязку данных к дисплею. Это делает общение между Presenter и View более кратким.

# 3.4.	SUMMARY
  Итак, что дает нам MVP?
  
  Это упрощает отладку в приложениях - MVP применяет три разных уровня абстракций, что упрощает отладку ваших приложений. Более того, поскольку бизнес-логика полностью отделена от View, при разработке приложения легче выполнять модульное тестирование.
  
  Кроме того, он обеспечивает лучшее разделение проблем - MVP отлично справляется с отделением вашей бизнес-логики и логики сохранения от ваших классов, что, в свою очередь, лучше обеспечивает хорошее разделение проблем.

  И, наконец, это улучшает повторное использование кода - в MVP код может быть лучше повторно использован, поскольку вы можете иметь несколько презентаторов, управляющих вашими представлениями. Это более важно, поскольку вы не хотите полагаться на одного докладчика для управления вашими различными представлениями.    

# 4.	MVVM
  MVVM расшифровывается как Model-View-ViewModel. С одной точки зрения, это можно рассматривать как эволюцию MVC, но с другой можно сказать, что MVVM принципиально отличается. Он был реализован в 2005 году Джоном Гроссманом. Основная идея этого шаблона состоит в том, что он пытается полностью отделить разработку представления и пользовательского интерфейса от разработки модели и бизнес-логики.

# 4.1.	MODEL
  ViewModel не может напрямую взаимодействовать с View. Вместо этого он представляет легко привязываемые свойства и методы в виде команд. View может связываться с этими свойствами, чтобы получать информацию от ViewModel и вызывать на ней команды (методы). Это не требует, чтобы View знал о ViewModel.
  
  Как и другие члены семейства MV *, модель в MVVM представляет данные или информацию о предметной области, с которыми будет работать наше приложение.

# 4.2.	VIEW      
  Как и в случае с MVC, представление - единственная часть приложения, с которой взаимодействуют пользователи. Это своего рода интерактивный интерфейс, который отображает состояние ViewModel.
  Active View в MVVM содержит привязки данных, события и поведение, и для этого требуется понимание ViewModel. View по-прежнему отвечает за обработку событий из ViewModel здесь.
  Важно помнить, что View не отвечает за состояние, он просто синхронизируется с ViewModel.

# 4.3.	VIEW-MODEL
  ViewModel можно рассматривать как специализированный контроллер, который действует как преобразователь данных. Он преобразует данные модели в данные просмотра, передавая команды из представления в модель.
  
  ViewModel также может предоставлять методы, помогающие поддерживать состояние представления, обновлять модель на основе действий из представления и запускать события в представлении.
  
  В результате ViewModel находится за уровнем пользовательского интерфейса. Он предоставляет данные из модели, которые нужны представлению, и может рассматриваться как источник, к которому представления имеют доступ как для данных, так и для действий.  

# 4.4.	SUMMARY
  MVVM упрощает параллельную разработку пользовательского интерфейса и строительных блоков, которые его используют.
  
  MVVM абстрагирует представление и, таким образом, сокращает количество бизнес-логики (или связующего звена), требуемого в коде, стоящем за ним. 
  
  ViewModel может быть проще для модульного тестирования, чем в случае кода, управляемого событиями.
  
  ViewModel (являющийся скорее моделью, чем представлением) можно протестировать, не беспокоясь об автоматизации пользовательского интерфейса и взаимодействии.

# CONCLUSION
  В MVC View находится поверх нашей архитектуры с контроллером рядом с ним. Модели располагаются под контроллером, поэтому наши представления знают о наших контроллерах, а контроллеры знают о моделях. Здесь наши представления имеют прямой доступ к моделям. Однако предоставление всей модели представлению может повлечь за собой затраты на безопасность и производительность в зависимости от сложности нашего приложения. MVVM пытается избежать этих проблем.

  В MVP роль контроллера заменена на Presenter. Докладчики сидят на одном уровне с представлениями, слушают события как из представления, так и из модели, и опосредуют действия между ними. В отличие от MVVM, здесь нет механизма привязки представлений к моделям представления, поэтому вместо этого мы полагаемся на каждое представление, реализующее интерфейс, позволяющий презентатору взаимодействовать с представлением.

  Следовательно, MVVM позволяет нам создавать специфичные для представления подмножества модели, которые могут содержать информацию о состоянии и логике, избегая необходимости открывать всю модель для представления. В отличие от Presenter MVP, ViewModel не требуется для ссылки на View. Представление может быть привязано к свойствам модели представления, которые, в свою очередь, предоставляют представлению данные, содержащиеся в моделях. Как мы уже упоминали, абстракция представления означает, что в коде, стоящем за ним, требуется меньше логики.  