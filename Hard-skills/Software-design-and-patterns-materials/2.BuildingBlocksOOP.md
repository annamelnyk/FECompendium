## 1. Inheritance
  1.1. **INTRO**
    - When it comes to inheritance, JavaScript only has one construct: objects. Each object has a private property which holds a link to another object called its prototype. That prototype object has a prototype of its own, and so on until an object is reached with null as its prototype. By definition, null has no prototype, and acts as the final link in this prototype chain.

    **Inheritance** is the mechanism of basing an object or class upon another object (prototypical inheritance) or class (class-based inheritance), retaining similar implementation. (Наследование - это механизм создания объекта или класса на основе другого объекта (прототипное наследование) или класса (наследование на основе классов) с сохранением аналогичной реализации).

    IS A relationship??

    В большинстве объектно-ориентированных языков на основе классов объект, созданный посредством наследования («дочерний объект»), приобретает все свойства и поведение родительского объекта.

  1.2.	**RECOGNIZING WHERE TO USE INHERITANCE**  
    Subclasses are specializations of their superclasses. 

    Абстрактные классы существуют для того, чтобы наследовать от них. Они предоставляют общий репозиторий, в котором хранится поведение, общее для всех подклассов, и каждый из них является специализацией абстрактного класса.
    Почти никогда не имеет смысла создавать абстрактный суперкласс с одним подклассом.

  1.3. **TEMPLATE METHOD PATTERN: DEFAULT IMPLEMENTATION**  
    Это дает подклассам возможность внедрять специализацию, переопределяя значения по умолчанию, установленные в родительском классе. Этот метод описания базовой структуры / алгоритма в суперклассе и переопределения частей этой структуры / алгоритма на те, которые уже специфичны для конкретного класса, называется методом шаблона.

  1.4. **USING HOOK MESSAGES: DECOUPLING SUBCLASSES (РАЗДЕЛЕНИЕ ПОДКЛАССОВ)**  
    Эта стратегия удаляет знание алгоритма из подкласса и возвращает управление суперклассу. Это было сделано путем добавления метода `postInitialize`.

   `RoadBike` и `MountainBike` больше не контролируют процесс инициализации, а вместо этого вносят специализацию в более абстрактный алгоритм. Этот алгоритм определен в абстрактном суперклассе `Bicycle`, который, в свою очередь, отвечает за отправку `postInitialize`.  

  1.5. **SUMMARY**
    • Наследование решает проблему связанных типов, которые имеют много общего поведения, но различаются по некоторым параметрам;
    • Лучший способ создать абстрактный суперкласс - это вытолкнуть код из конкретных подклассов;
    • Абстрактные суперклассы используют шаблон метода шаблона, чтобы пригласить наследников для предоставления специализаций, и они используют hooks methods, чтобы позволить этим наследникам вносить эти специализации без принудительной отправки super;
    • Хорошо спроектированные иерархии наследования легко расширять новыми подклассами даже для программистов, которые очень мало знают о приложении; 

## 2.INTERFACE 
  **Found in internet:**
----------
  Интерфейс это фактически регламент взаимодействия.
  Класс который реализует интерфейс обязан реализовывать все его методы.
  В интерфейсе вы описываете лишь сигнатуры методов, то есть вы указываете что класс наследник должен уметь делать, но как он будет это делать, тот решает сам.
  Таким образом вы уверены, что если класс реализует тот или иной интерфейс, все объекты данного класса имеют определенный набор методов.
  ООП - мир абстракций. Интерфейсы это еше одна абстракция позволяющая отделить описание от реалзиации.

  Интерфейсы располагаются на уровень выше классов, если можно так выразиться. Они неявно "объединяют" классы схожие по каким то общим признаком, и которые обязаны (по логике вашего приложения) реализовывать те или иные методы.
---------
  ООП напрямую связано с сообщениями, отправляемыми между объектами. Более того, важно не только то, что объекты знают, какое у них поведение внутри, от кого они зависят (кому отправляются сообщения), но и как они общаются друг с другом. Объекты общаются через интерфейсы.

  **PUBLIC INTERFACES**
    •	Reveal its primary responsibility. (Раскройте свою главную ответственность)
    •	Are expected to be invoked by others. (Ожидается, что на них будут ссылаться другие)
    •	Will not change on a whim. (Не изменится по прихоти)
    •	Are safe for others to depend on.(Безопасны для других)
    •	Are thoroughly documented in the tests. (Тщательно задокументированы в тестах)
  
  **PRIVATE INTERFACES**
    •	Handle implementation details. (Обработка деталей реализации)
    •	Are not expected to be sent by other objects. (Не предполагается, что они будут отправлены другими объектами)
    •	Can change for any reason whatsoever. (Может измениться по любой причине)
    •	Are unsafe for others to depend on. (Небезопасно полагаться на других)
    •	May not even be referenced in the tests. (Может даже не упоминаться в тестах)

  Что нам дают интерфейсы? Наличие интерфейсов позволяет думать о задаче более абстрактно, игнорируя второстепенные детали.
  Есть разные уровни абстракции или незнания деталей.
  Каждый конкретный класс абстрактен и имеет скрытое поведение. И класс будет реализован, какой-то интерфейс будет зависеть не от требований абстракции, а от модели.  

  2.1. **When should a class implement an Interface?**
    1.	Class implements Strategy pattern or it is part of family of objects: IRepository, IFormatter, IPrecondition;
    2.	Class implements role interface (as a result of ISP): ICloneable, IComparable, etc.;
    3.	Class implements interface required for connection with other classes. Class is an Adapter, the need for an interface is determined by DIP;
    4.	Class implements interface, because external environment depends on it. Provides testability to users of this class. This is not a single reason to create an interface.

  2.2.	**WHEN SHOULD A CLASS DEPEND ON AN INTERFACE?**  
   **Don’t create interfaces “Just in case”!**
  
   Когда класс должен зависеть от интерфейса? Например, получить его через конструктор. Аргументы класса указывают на то, что он не может принять какое-то решение самостоятельно и ему нужна помощь вызываемого класса.
   Проще всего, когда класс зависит от примитивов, немного сложнее, когда он зависит от определенных классов, и сложнее всего, когда он зависит от интерфейса.
    
    1. Класс имеет дело с семейством типов: “family of types” уже существует и определяется требованиями существующей модели;
    2. В результате DIP: класс хочет общаться с объектом другого уровня, он сам определяет интерфейс и требует его реализации;
    3. Для тестирования: полезно в случае, если реализация абстракции зависит от внешней среды.

  2.3. **SUMMARY: CREATING A MESSAGE-BASED APPLICATION**

  1. Создание явных интерфейсов - каждый раз, когда вы создаете класс, объявляйте его интерфейсы.

    Методы в общедоступном интерфейсе должны:
    • явным образом идентифицироваться как таковой.
    • Больше о том, что, чем о том, как.
    • Иметь имена, которые, насколько вы можете ожидать, не изменятся.

  2. Уважайте публичные интерфейсы других - делайте все возможное, чтобы взаимодействовать с другими классами, используя только их общедоступные интерфейсы.

  3. Соблюдайте осторожность при зависимости от частных интерфейсов - несмотря на все ваши усилия, вы можете обнаружить, что должны зависеть от частного интерфейса, это опасная зависимость, которую следует изолировать.
  
  4. Минимизируйте контекст - создавайте общедоступные интерфейсы с прицелом на минимизацию контекста, который они требуют от других. Помните о различии «что и как»; создавать общедоступные методы, которые позволяют отправителям получать то, что они хотят, не зная, как ваш класс реализует свое поведение.

## 3.	THE LAW OF DEMETER  
  **Only talk to your immediate neighbors, or in other words: use only one dot. (Говорите только со своими ближайшими соседями,
  или другими словами: используйте только одну точку.)**

  **Цель закона Деметрa** - более низкая сплоченность. Низкое сцепление свидетельствует о хорошем качестве конструкции. Вкратце закон Деметры звучит так:`Говорите только со своими ближайшими соседями, или другими словами: используйте только одну точку.`

  Некоторые нарушения Закона Деметра безвредны, хотя другие являются признаком того, что публичный интерфейс не был отделен правильно или не был отделен вообще.

  3.1.	**AVOIDING VIOLATIONS (ИЗБЕЖАНИЕ НАРУШЕНИЙ)**
  To avoid such problems, you need to think over the application architecture in advance.

  **Delegation is an effective technique to avoid Law of Demeter violations, but only for behavior, not for attributes.**
  Делегирование - это эффективный способ избежать нарушений закона Деметры, но только в отношении поведения, а не атрибутов.

4.	**INTERFACE VS ABSTRACT CLASS**  
  **Интерфейс** более гибкий с точки зрения клиента: любой класс может реализовать любой интерфейс. Но интерфейс «жестче» с точки зрения разработчика:
  его сложнее изменить (нарушится работа всех клиентов), на конструктор клиента нельзя наложить ограничения, нельзя повторно использовать код.
  
  Важные причины использования интерфейсов:
  • Интерфейсы используются для достижения абстракции.
  • Разработан для поддержки разрешения динамических методов во время выполнения.
  • Это помогает добиться слабого сцепления.
  • Позволяет отделить определение метода от иерархии наследования.

  **Абстрактный класс** «жестче» с точки зрения клиентов: клиент будет вынужден отказаться от текущего базового класса. Но абстрактный класс «более гибкий» 
  с точки зрения разработчика: он позволяет повторно использовать код, ограничивать конструктор потомков, позволяет вносить изменения
  (легко добавлять виртуальный метод, не нарушая работу существующих клиентов) и т. Д. четко определите «контракт» с потомками с помощью шаблонных методов.
  
  Важные причины использования абстрактного класса:
  • Абстрактные классы предлагают функциональность по умолчанию для подклассов.
  • Предоставляет шаблон для будущих конкретных классов
  • Помогает вам определить общий интерфейс для его подклассов
  • Абстрактный класс допускает повторное использование кода.

## INTERFACES (НЕ из лекции, важная информация)
  - В наиболее распространенной форме интерфейс - это группа связанных методов с пустыми телами
  - Реализация интерфейса позволяет классу стать более формальным в отношении поведения, которое он обещает обеспечить. Интерфейсы образуют контракт между классом и внешним миром, и этот контракт применяется компилятором во время сборки. Если ваш класс утверждает, что реализует интерфейс, все методы, определенные этим интерфейсом, должны появиться в его исходном коде, прежде чем класс будет успешно скомпилирован.

  - Interfaces and Inheritance.
  An interface can be extended by other interfaces. In other words, an interface can inherit from other interface. Typescript allows an interface to inherit from multiple interfaces. Use the extends keyword to implement inheritance among interfaces.


