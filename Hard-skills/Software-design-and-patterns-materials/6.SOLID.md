# 1.1.	DESIGN PRINCIPLES OVERVIEW
  Критерии, описывающие качество кода или дизайна: цикломатическая сложность методов, глубина иерархии наследования, количество строк методов и т. д.

  Сode smells, которые усложняют наши системы:
    • Жесткость - сложно изменить.
    • Хрупкость - легко сломается.
    • Неподвижность - трудно использовать повторно.
    • Вязкость - сложно выбрать правильный способ внесения изменений.
    • Излишняя сложность - чрезмерный дизайн.

# 1.2.	WHAT IS SOLID?
  SOLID - это аббревиатура, использованная Робертом К. Мартином (также известным как дядя Боб) для первых пяти принципов объектно-ориентированного проектирования. Он не изобретал и не открывал их, а просто структурировал и объединил в набор из 5 общеизвестных нам принципов.
  
  Принципы SOLID позволяют адаптировать разработку и проектирование программного обеспечения к изменениям, легко масштабировать и поддерживать.    

# 2.	SINGLE RESPONSIBILITY PRINCIPLE (SRP)
  **DEFINITION**
    Классы, программные компоненты и микросервисы, которые несут только одну ответственность, гораздо легче объяснить, понять и реализовать, чем те, которые обеспечивают решение для всего. Это уменьшает количество ошибок, повышает скорость разработки и значительно упрощает вашу жизнь как разработчика программного обеспечения.

    Если вы создаете свое программное обеспечение в течение более длительного периода и вам необходимо адаптировать его к меняющимся требованиям, может показаться, что самый простой и быстрый подход - добавить метод или функциональность в существующий код вместо написания нового класса или компонента. Но это часто приводит к тому, что классы становятся более ответственными, и поддерживать программное обеспечение становится все труднее и труднее.
    Вы можете избежать этих проблем, задав простые вопросы, прежде чем вносить какие-либо изменения:
    • Этот класс делает слишком много? Правильный ответ: Нет, он отвечает только за одну конкретную функцию.
    • Сколько источников новых требований есть у этого класса? Правильный ответ: единый источник или новые требования.
    • Перед кем несет ответственность этот класс? Правильный ответ: это ответственность только перед одним человеком или ролью.

  **SUMMARY**
    Когда использовать?
    
      • Ваш модуль постоянно меняется, и требования к изменениям исходят от разных ролей в вашем проекте.
      • Действия в модуле не коррелируют друг с другом.
      • Логика модуля слишком сложна для понимания и / или тестирования.
    
    Как применить?
    
      • Объединяйте вещи, которые меняются по одной причине. Разделяйте вещи, которые меняются по разным причинам.
      • Изолировать изменения, логически отделить составные части модуля.
      • Уменьшите зависимости.
      • Применяйте принцип только тогда, когда это важно. Не вводите лишних зависимостей.  

# 3.	OPEN-CLOSED PRINCIPLE (OCP)    
  **DEFINITION**
    Модули имеют две основные характеристики:
      • Они открыты для расширения. Это означает, что поведение модуля можно расширить. Когда требования к приложению меняются, мы добавляем новое поведение в модуль, чтобы соответствовать изменившимся требованиям.
      • Они закрыты для модификации. Это означает, что расширение поведения модуля не влечет за собой изменений исходного кода модуля.

    Другими словами, мы должны иметь возможность изменять поведение модуля без изменения самого модуля. Как этого добиться?  
  
  **SUMMARY**
    Итак, цель OCP - минимизировать изменения существующих классов при добавлении новых функций. Это достигается за счет добавления точек расширения (а не только наследования), которые позволяют нам использовать преимущества мощных инструментов, таких как композиция, агрегация и полиморфизм.

# 4.	LISKOV SUBSTITUTION PRINCIPLE (LSP)    
  **DEFINITION**
    Принцип определяет, что объекты суперкласса должны быть заменены объектами его подклассов без нарушения работы приложения. Это требует, чтобы объекты ваших подклассов вели себя так же, как объекты вашего суперкласса. Клиенты могут надежно использовать любой тип или подтип, всегда ожидая согласованного поведения или, другими словами, сохранения контракта. Простая формулировка принципа такова: должна существовать возможность замены базового типа на любой подтип.
    
    Есть несколько «правил», которые необходимо соблюдать для соответствия LSP: правила контракта и правила отклонения.

  **CONTRACT RULES**
    - Preconditions cannot be strengthened in a subtype
    - Postconditions cannot be weakened in a subtype

  **ПРАВИЛА ВАРИАНТА**  
    - There must be covariance of the return types in the subtype.
    - There must be contravariance of the method arguments in the subtype.
    - Invariants must be maintained.

  **SUMMARY**
    В случае несоблюдения LSP:
      • Иерархия наследования приведет к путанице. Таким образом, передача экземпляра подкласса вместо базового класса в метод приведет к странному поведению существующего кода.
      • Модульные тесты для базового класса никогда не пройдут для подклассов.

# 5.	INTERFACE SEGREGATION PRINCIPLE (ISP)
  **DEFINITION**
    Цель этого принципа - уменьшить побочные эффекты от использования интерфейсов большего размера за счет разделения интерфейсов приложений на более мелкие. Это похоже на принцип единой ответственности, в котором каждый класс или интерфейс служат одной цели.
    
    Точный дизайн приложения и правильная абстракция - это ключ к принципу разделения интерфейса. Хотя это займет больше времени и усилий на этапе разработки приложения и может увеличить сложность кода, в конечном итоге мы получаем гибкий код.

   **SUMMARY**
    Как видите, толстые интерфейсы приводят к непреднамеренному связыванию между классами, и вам следует избегать их. При разработке интерфейсов вы всегда должны задавать себе вопрос: «Действительно ли нужны все методы этого интерфейса, которые я использую? Если нет, как я могу разбить их на более мелкие интерфейсы? ». Относитесь к разделению интерфейса с определенным прагматизмом и руководствуйтесь здравым смыслом.

# 6.	DEPENDENCY INVERSION PRINCIPLE (DIP)
  **DEFINITION**
    Общая идея этого принципа настолько же проста, насколько и важна: модули высокого уровня, которые обеспечивают сложную логику, должны легко повторно использоваться и не подвергаться изменениям в модулях низкого уровня, которые предоставляют служебные функции. Для этого вам необходимо ввести абстракцию, которая отделяет модули высокого и низкого уровня друг от друга. Принцип проектирования не просто меняет направление зависимости, как вы могли ожидать, когда впервые читали его название. Он разделяет зависимости между высокоуровневыми и низкоуровневыми модулями, вводя между ними абстракцию. Итак, в итоге вы получаете две зависимости: модуль высокого уровня зависит от абстракции, а модуль низкого уровня зависит от той же абстракции.

  **SUMMARY**      
    Принцип инверсии зависимостей вводит абстракцию интерфейса между программными компонентами верхнего и нижнего уровня, чтобы удалить зависимости между ними.

    Когда выделять интерфейс из класса?
      • Класс - это реализация некоторой стратегии и будет использоваться полиморфно.
      • Класс используется для работы с внешними средами (файлы, сокеты, конфигурация и т. Д.).
    
    Когда не выделять интерфейс класса?
      • Класс - это неизменяемый объект значения или объект данных.
      • Класс имеет стабильное поведение (не работает с внешней средой).

