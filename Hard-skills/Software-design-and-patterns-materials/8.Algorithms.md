# ALGORITHMS AND DATA STRUCTURES 
 
 # 1.	ALGORITHMS
  **Алгоритм** - это последовательность вычислительных шагов, которые преобразуют входные данные в выходные.
  В постановке задачи в общих чертах указывается желаемое соотношение ввода / вывода. Алгоритм описывает конкретную вычислительную процедуру для достижения этого отношения ввода / вывода.

  # 1.1.	ALGORITHM CHARACTERISTICS
  Классификации алгоритма с использованием множества критериев. Некоторые алгоритмы работают со своими наборами данных последовательно, что означает, что они являются последовательными по своей природе. В то время как параллельный алгоритм может разбить набор данных на более мелкие части, а затем работать с каждым из них одновременно.
  
  Алгоритм может быть точным, и в этом случае он дает известное предсказуемое значение, или может быть приблизительным, и в этом случае он пытается найти ответ, которого может не быть. Например, алгоритм распознавания лиц может не давать каждый раз один и тот же ответ с одним и тем же лицом.
  
  Алгоритмы могут быть детерминированными, и в этом случае они выполняют каждый шаг с точным решением, и он может быть недетерминированным, если они пытаются найти решение, используя последовательные предположения, которые со временем становятся более точными.

 # 1.2.	COMMON ALGORITHMS
  # 1.2.1.	Search algorithms
    Такого рода алгоритмы находят определенные данные в структуре. (например, подстрока в строке). Один из наиболее распространенных типов алгоритмов, с которыми вы сталкиваетесь, - это алгоритмы поиска, которые используются, когда вам нужно найти фрагмент данных в более крупной структуре данных. Например, поиск подстроки в более крупной строке или, возможно, поиск файла в наборе подпапок в файловой системе.
  
  # 1.2.2.	Sorting algorithms
    Алгоритмы сортировки - еще один очень распространенный тип, используемый при работе с упорядоченными наборами данных. И, как вы уже догадались, они берут набор данных и размещают их в определенном порядке.

  # 1.2.3.	Computational algorithms
    Учитывая один набор данных, рассчитайте другой на основе этого набора. Вычислительные алгоритмы используются для перехода от одного набора данных к другому. И простой пример: вычислить, является ли данное число простым числом, или, возможно, преобразовать температуру из одной шкалы в другую.

  # 1.2.4.	Collection algorithms
    Работа с коллекциями данных (подсчет определенных элементов, переход между элементами данных, фильтрация нежелательных данных и т. Д.). Наконец, существуют алгоритмы сбора, которые включают манипулирование или перемещение между наборами данных, которые хранятся в определенной структуре. Здесь легко представить примеры, которые подсчитывают количество конкретных элементов, отфильтровывают нежелательные данные и так далее.

 # 1.3.	ALGORITHM PERFORMANCE      
    Поскольку алгоритмы предназначены для работы с наборами данных и решения вычислительных задач, важно понимать, как говорить о производительности алгоритма. Это важный фактор при выборе конкретного алгоритма для решения вычислительной задачи, а также для понимания того, как ваша программа будет вести себя в различных обстоятельствах.

    Итак, мы хотим измерить, как изменяется производительность алгоритма в зависимости от размера входного набора данных. Вы часто будете слышать термин, называемый нотацией Big-O, который используется для описания производительности алгоритма. Этот формат записи используется для описания того, как работает конкретный алгоритм, когда набор входных данных растет с течением времени. И причина, по которой используется буква O, заключается в том, что скорость, с которой растет сложность алгоритма, также называется порядком работы. Обычно он описывает наихудший сценарий того, сколько времени потребуется для выполнения данной операции. И важно отметить, что многие разные алгоритмы и структуры данных имеют более одного значения Big-O. Например, структуры данных обычно могут выполнять несколько типов операций, таких как вставка или поиск значений, каждая со своим порядком операций.  

    Самый простой пример - это то, что называется постоянным временем, и это соответствует Big-O, равному единице. По сути, это означает, что рассматриваемая операция не зависит от количества элементов в данном наборе данных. Хорошим примером этого является вычисление четного или нечетного числа или поиск определенного индекса элемента в массиве.

    Далее идет порядок log n, который называется логарифмическим временем. И типичный пример такого рода операций - поиск определенного значения в отсортированном массиве с помощью двоичного поиска. Таким образом, по мере роста количества элементов в отсортированном массиве для поиска любого заданного элемента требуется только логарифмическое отношение времени.

    Следующее - линейное время, которое соответствует Big-O из n, и этот уровень временной сложности соответствует типичному примеру поиска элемента в несортированном массиве.

    У нас также есть порядок n раз log (n) или так называемая логарифмическая временная сложность. Примерами могут быть некоторые алгоритмы сортировки, такие как сортировка кучи и сортировка слиянием.

    И, наконец, порядок n в квадрате, который называется квадратичной временной сложностью, и, как вы, наверное, догадались, это не очень хороший уровень производительности, потому что это означает, что по мере увеличения количества элементов в наборе данных время требуется для обработки, они увеличиваются в квадрате этого числа. Примером может служить несколько более простых алгоритмов сортировки, таких как пузырьковая сортировка и выборочная сортировка.

  # 1.4.	CORRECTNESS OF ALGORITHM (ПРАВИЛЬНОСТЬ АЛГОРИТМА)
    Алгоритм считается правильным, если на любом допустимом (для данной задачи) входе он завершает свою работу и дает результат, соответствующий требованиям задачи. В этом случае говорят, что алгоритм решает данную вычислительную задачу. Неправильный алгоритм (для некоторого ввода) может вообще не останавливаться или давать неверный результат, но это не означает, что такие алгоритмы совершенно бесполезны. Если ошибки достаточно редки или можно контролировать частоту ошибок, мы можем допустить использование некорректных алгоритмов. Возможно, изначально у нас есть конкретная задача с одним набором данных и мы составили алгоритм. Потом начинают поступать какие-то новые данные, их немного, но с ними алгоритм значительно тормозит. Но поскольку таких данных пока немного, алгоритм вполне рабочий.

  # 1.5.	ANALYZING ALGORITHM
    Анализ алгоритма стал означать прогнозирование ресурсов, которые требуются алгоритму. Иногда такие ресурсы, как память, полоса пропускания связи или компьютерное оборудование, имеют первостепенное значение, но чаще всего мы хотим измерить время вычислений. Как правило, анализируя несколько алгоритмов-кандидатов для решения проблемы, мы можем определить наиболее эффективный. Такой анализ может указать более чем на одного жизнеспособного кандидата, но мы часто можем отбросить несколько низших алгоритмов в процессе.

    Прежде чем мы сможем проанализировать алгоритм, у нас должна быть модель технологии реализации, которую мы будем использовать, включая модель ресурсов этой технологии и их стоимости. В этой лекции мы примем универсальную модель вычислений с одним процессором и машиной с произвольным доступом (RAM) в качестве технологии реализации и поймем, что наши алгоритмы будут реализованы в виде компьютерных программ. В модели RAM инструкции выполняются одна за другой, без одновременных операций.     

  # 2.	INSERTION SORT
    Сортировка вставкой - это простой алгоритм сортировки, который работает аналогично тому, как вы сортируете игральные карты в руках. Массив виртуально разделен на отсортированную и несортированную части. Значения из неотсортированной части выбираются и помещаются в правильное положение в отсортированной части.
    
    Чтобы отсортировать массив размера n в порядке возрастания (рисунок 2):
      • Переход от arr [1] к arr [n] по массиву.
      • Сравните текущий элемент (ключ) с его предшественником.
      • Если ключевой элемент меньше своего предшественника, сравните его с предыдущими элементами. Переместите большие элементы на одну позицию вверх, чтобы освободить место для замененного элемента.  

    Время выполнения процедуры insertSort зависит от набора входных значений: сортировка тысяч чисел занимает больше времени, чем сортировка трех чисел. В общем случае время работы алгоритма увеличивается с увеличением количества входных данных, поэтому общепринято представлять время выполнения программы как функцию, зависящую от количества входных элементов. Для этого необходимо более точно определить понятия «время алгоритма» и «размер входных данных».
    
    Наиболее адекватная концепция размера входных данных зависит от рассматриваемой проблемы. Для каждой рассматриваемой ниже задачи будет указан способ измерения размера входных данных. В случае insertSort количество входных элементов рассматривается как размер входных данных.  
    
  #  2.1.	ASYMPTOTIC NOTATION (АСИМПТОТИЧЕСКИЕ ОБОЗНАЧЕНИЯ)
  # 3.	DIVIDE AND CONQUER
    Мы можем выбирать из широкого спектра методов разработки алгоритмов. Для сортировки вставкой мы использовали инкрементный подход: отсортировав подмассив A [1 .. j-1, мы вставили единственный элемент A [j] на его надлежащее место, получив отсортированный подмассив A [1 .. j].

    Здесь мы рассмотрим альтернативный подход к проектированию, известный как «разделяй и властвуй». Мы будем использовать принцип «разделяй и властвуй», чтобы разработать алгоритм сортировки, время работы которого в наихудшем случае намного меньше, чем время сортировки вставкой. Одним из преимуществ алгоритмов «разделяй и властвуй» является то, что время их работы часто легко определяется.

    Многие полезные алгоритмы рекурсивны по структуре: для решения данной проблемы они рекурсивно вызывают себя один или несколько раз для решения тесно связанных подзадач. Эти алгоритмы обычно следуют подходу «разделяй и властвуй»: они разбивают проблему на несколько подзадач, похожих на исходную, но меньшего размера, рекурсивно решают подзадачи, а затем объединяют эти решения для создания решения исходной проблемы.

    Парадигма «разделяй и властвуй» включает три этапа на каждом уровне рекурсии:
      • Разделите проблему на несколько подзадач, которые представляют собой более мелкие экземпляры одной и той же проблемы.
      • Преодолейте подзадачи, решая их рекурсивно. Однако, если размеры подзадач достаточно малы, просто решите подзадачи простым способом.
      • Объедините решения подзадач в решение исходной проблемы.
      
    Алгоритм сортировки слиянием следует парадигме «разделяй и властвуй». Интуитивно он работает следующим образом.
      • Разделить: разделите последовательность из n элементов, которую нужно отсортировать, на две подпоследовательности по n / 2 элемента в каждой.
      • Conquer: рекурсивная сортировка двух подпоследовательностей с помощью сортировки слиянием.
      • Объединить: объединить две отсортированные подпоследовательности для получения отсортированного ответа.

  # 3.1.	MERGE SORT
    Так будет выглядеть mergeSort. Берем половину длины массива и делим его на две части. И мы вызываем функцию слияния для такой же сортировки слева и справа. Сама функция слияния сравнивает и объединяет наши последовательности.

    Хотя код для сортировки слиянием работает правильно, когда количество элементов не является четным, наш анализ на основе рекурсии упрощается, если мы предполагаем, что исходный размер проблемы равен степени 2. Каждый шаг деления затем дает две подпоследовательности размером ровно n / 2. Это предположение не влияет на порядок роста решения до повторяемости.

    Мы рассуждаем следующим образом, чтобы установить повторение для T (n), наихудшего времени выполнения сортировки слиянием для n чисел. Сортировка слиянием только одного элемента занимает постоянное время. Когда у нас n> 1 элементов, мы разбиваем время выполнения следующим образом.    

    Разделить: на этапе деления просто вычисляется середина подмассива, что занимает постоянное время. Таким образом, D (n) = Θ (1)
    Conquer: мы рекурсивно решаем две подзадачи, каждая размером n / 2, что дает 2T (n / 2) времени выполнения.
    Комбинирование: мы уже отметили, что процедура MERGE на подмассиве из n элементов требует времени Θ (n), поэтому C (n) = Θ (n).

  # 4.	HEAP. HEAP SORT. PROIRITY QUEUE  