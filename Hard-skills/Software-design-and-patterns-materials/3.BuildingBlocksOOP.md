## 1.	COMPOSITION
  Композиция - одно из фундаментальных понятий объектно-ориентированного программирования. Он описывает класс, который ссылается на один или несколько объектов других классов в переменных экземпляра. Это позволяет смоделировать связь между объектами «есть-а». Такие отношения довольно часто можно встретить в реальном мире. Например, у автомобиля есть двигатель, а современные кофемашины часто имеют встроенную кофемолку и заварочный блок. Каждая часть по отдельности может не иметь для нас особой ценности, например, музыкальная нота не содержит большого количества информации, а с помощью композиции мы можем создать музыкальную композицию, которая может дать нам гораздо больше информации, чем каждая нота в отдельности.

  **1.2.	COMPOSITION VS INHERITANCE**
  Сравнивая композицию с наследованием, мы можем сказать, что наследование моделирует сильную связь «есть-а» между классами, это означает, что горный велосипед - это велосипед, а композиция моделирует более слабую связь «имеет-а» - у горного велосипеда есть колесо.

  **1.3.	MOVING FROM INHERITANCE TO COMPOSITION**
    const roadBike = new Bicycle(
      'M',
      new Parts([
        new Part('chain', '11-speed'),
        new Part('tireSize', '28'),
        new Part('tapeColor', 'red')
      ])
    );
    const mountainBike = new Bicycle(
      'L',
      new Parts([
        new Part('chain', '11-speed'),
        new Part('tireSize', '29'),m
        new Part('readShock', 'fox', false),
        new Part('frontShock', 'manitou')
      ])
    );

    Вместо наследования, используем композицию - т.е. в конструктор передаем аргументом другой конструктор.

  **1.4.	COMPOSITION: ACCEPTING THE CONSEQUENCES OF INHERITANCE (ПРИНЯТИЕ ПОСЛЕДСТВИЙ НАСЛЕДОВАНИЯ)**  
  «Наследование лучше всего подходит для  добавления функциональности к существующим классам, когда вы будете использовать большую часть старого кода и добавлять относительно небольшие объемы нового кода».

  **1.4.1.	Benefits of Inheritance**
    • Использование наследования приводит к созданию кода, который можно охарактеризовать как открытый-закрытый; иерархии открыты для расширения, но остаются закрытыми для модификации.
    • Правильно написанные иерархии легко расширять. Иерархия воплощает абстракцию, и каждый новый подкласс включает несколько конкретных отличий. Существующий шаблон легко повторить и повторить. Иерархии по своей природе служат руководством для написания кода для их расширения.
    • Используйте наследование для отношений "есть-а"

  **1.4.2.	Costs of Inheritance**
    • Выбор наследования для решения неправильного типа проблемы.
    • Высокая стоимость внесения изменений в верхнюю часть неправильно смоделированной иерархии. В этом случае эффект использования заемных средств работает в вашу пользу; небольшие изменения все ломают.
    • Невозможность добавления поведения, когда новые подклассы представляют собой смесь типов.

**1.5.	COMPOSITION: ACCEPTING THE CONSEQUENCES OF COMPOSITION (ПРИНЯТИЕ ПОСЛЕДСТВИЙ КОМПОЗИЦИИ)**
  «Используйте композицию, когда поведение - это больше, чем сумма его частей». —Парафраз Грэди Буча, объектно-ориентированный анализ и дизайн

**1.5.1.	Benefits of Composition**  
    • При использовании композиции естественной тенденцией является создание множества небольших объектов, содержащих простые обязанности, которые доступны через четко определенные интерфейсы.
    • Эти небольшие объекты несут единственную ответственность и определяют свое собственное поведение. Они прозрачные; код легко понять и понятно, что будет, если он изменится.
    • Поскольку составные объекты взаимодействуют со своими частями через интерфейс, добавление нового типа части представляет собой простой вопрос подключения нового объекта, который учитывает интерфейс.
    • Используйте композицию для отношений типа «есть-а».

**1.5.2.	Costs of Composition**
    • Сложный объект состоит из множества частей. Даже если каждая часть небольшая и легко понимаемая, совместное действие целого может быть менее чем очевидным.
    • Преимущества структурной независимости достигаются за счет автоматического делегирования сообщений. Составной объект должен явно знать, какие сообщения и кому делегировать.
    • Как показывают эти затраты и выгоды, композиция отлично подходит для предписания правил для сборки объекта, состоящего из частей, но не оказывает такого большого содействия в решении проблемы организации кода для набора частей, которые почти идентичны.    

**2.	DUCK TYPING**
**2.1.	IF IT WALKS LIKE A DUCK AND TALKS LIKE A DUCK THEN IT’S A DUCK**  
**2.2.	FINDING THE DUCK**
**2.3.	WRITING CODE THAT RELIES(ОПРЕДЕЛЯЕТ) ON DUCKS**
  Обобщая информацию о типах уток, мы попытаемся составить список основных моментов, которые помогут нам написать код с использованием типов уток.
  1) Распознавание скрытых уток. Вам необходимо своевременно понять, где скрываются типы уток и как их извлечь, обратите внимание на следующие места в коде:
    а) Операторы case, которые включают класс.
    б) Оператор Instanceof.
    c) Проверка существования метода (if (obj.someMethod) {obj.someMethod ()});
  2) Доверяйте своим уткам. Позвольте клиентскому коду доверять типу утки, отсутствие доверительного клиентского кода означает следующее: «Я знаю, кто вы, поэтому я знаю, что вы делаете». Такие знания превращаются в тесную связь между классами, что приводит к нерасширяемому коду. Гибкие приложения, построенные на основе объектов, которые работают на доверии - ваша цель как разработчика - сделать эти объекты надежными, чтобы доверие работало.
  3) Документирование типов уток. Тип утки Preparer и его открытый интерфейс - это особая часть дизайна, но в то же время это виртуальная часть кода, потому что это не класс и не реальный интерфейс. Препараторы - это абстракция, просто соглашение, которое дает вам мощный инструмент проектирования системы, но эта абстракция делает код менее очевидным. Когда вы создаете тип утки, вы должны задокументировать и покрыть его тестами.
  4) Совместное использование кода утками. В нашем примере используется только метод prepareTrip, но когда вы начнете использовать типы утки, вы можете заметить, что некоторая часть функциональности является общей для всех типов. Делитесь такой функциональностью с помощью миксинов и других доступных подходов.
  5) Выбирайте уток с умом. Последний пункт, как всегда, говорит нам о том, что вам не нужно создавать типы уток только для того, чтобы они были. Вам необходимо найти баланс между ресурсами, необходимыми для рефакторинга, полученными преимуществами, простотой поддержки и ясностью кода.

**3.	MIXINS**
**3.1.	SHARING ROLE BEHAVIOR WITH MIXINS**  
  Mixins - это еще один инструмент OOD, наследование - не единственный способ поделиться поведением, каждая проблема, которую мы решаем с помощью наследования, также может быть решена с помощью других инструментов, и одним из таких инструментов являются миксины. Но у каждого инструмента есть свои плюсы и минусы, поэтому давайте посмотрим, что могут дать нам миксины и какую цену мы должны заплатить за их использование.

    Object.assign(
      User.prototype,
      sayHiMixin
    );

    new User('Dave').sayHi();

  Но такой подход имеет некоторые последствия, функциональность прототипов не самая удобная в использовании, кроме того, Object.assign делает только мелкую копию, поэтому вы можете использовать существующие библиотеки JS, чтобы упростить использование миксинов.

**3.4.	MIXINS: WRITING INHERITABLE CODE**
  • Распознавать антипаттерны. Есть два антипаттерна, которые могут указывать на то, что вы можете получить выгоду от наследования. Первый из них - использование переменных с типом / категорией для определения типа объекта и отправки ему сообщения. Второй - использование прямой проверки типа объекта или оператора switch-case - тогда вы скорее пропустили тип утки. Типы уток могут иметь не только общий интерфейс, но и общее поведение, которое рекомендуется извлекать в миксины.
  • Настаивайте на абстракции. Весь код в абстрактном суперклассе, который должен использоваться в каждом подклассе, суперклассы не должны содержать код, который применяется только для некоторых подклассов. Это ограничение также применимо к миксинам, все функции миксина должны использоваться везде, где они смешаны. Если вы не можете идентифицировать абстракцию, то, вероятно, она не существует, и наследование не может быть применено для решения этой проблемы.
  • Соблюдайте договор. Подклассы должны учитывать контакт, чтобы их можно было легко заменить суперклассами без каких-либо изменений в поведении системы. Это означает, что они должны отвечать на одни и те же сообщения, получая одни и те же входные данные и возвращая одни и те же данные результата. Таким образом, они не могут сделать что-то, что заставит клиентский код проверить их на тип, чтобы понять, чего от них ждать. Подклассы, которые не соблюдают контракт, не могут работать синхронно, что делает всю иерархию наследования непредсказуемой. Это также нарушает принцип замещения Лискова, о котором вы узнаете из лекции о SOLID.
  • Упреждающее разделение классов. Старайтесь избегать вызова суперметода, вместо этого используйте шаблон метода и так называемые хуки, они дают подклассу возможность указать общий алгоритм, которым управляет суперкласс. Помните, что это не «серебряная пуля», и не следуйте этому подходу вслепую.
  • Создайте мелкие иерархии (рисунок 9). Постарайтесь создать как можно более компактные иерархии. Мелкие иерархии легко понять, мелкие и широкие немного сложнее, но их все же легко понять. Глубокие и узкие иерархии имеют тенденцию становиться шире, и их становится все труднее понять и поддерживать. Вам следует избегать глубоких и широких иерархий, они создают длинный путь к целевому методу или свойству, которого нет в целевом классе. Такие иерархии сложно поддерживать, и они создают высокий риск сбоя приложения.

**4.	DESIGN BY CONTRACT**  
  **4.1.	CORRECTNESS**
  Дизайн по контракту (DbC), также известный как контрактное программирование, программирование по контракту и программирование по контракту, - это подход к разработке программного обеспечения. Он предписывает разработчикам программного обеспечения определять формальные, точные и поддающиеся проверке спецификации интерфейса для компонентов программного обеспечения, которые расширяют обычное определение абстрактных типов данных предварительными условиями, постусловиями и инвариантами. Эти спецификации называются «контрактами» в соответствии с концептуальной метафорой условий и обязательств деловых контрактов.
  Прежде чем мы перейдем к контрактам, нам нужно понять, почему нам нужно изучать эту тему, и первый термин, который нам нужно понять, - это **правильность системы**.

  //Example 1
  const doSomething = (x) => {
    return x / 2;
  }

  //Example 2
  // { x = 5 } x = x ˆ 2 { x > 0 } => the weakest postcondition

  //Example 3
  // { x = 5 } x = x ˆ 2 { x = 25 } => the strongest postcondition

  Сама по себе эта функция не является ни правильной, ни неправильной, правильность может быть применена, когда мы будем говорить об ожидаемых результатах. Эта функция верна, если мы говорим, что «Возвращаемое значение составляет половину размера аргумента», но неверно, если мы скажем, что «Возвращаемое значение должно быть положительным», потому что нет никаких гарантий, что функция не получит отрицательный результат. число в качестве аргумента.
  Этот пример проясняет, что правильность может быть применена к спецификации, но не к коду функции.
  Следующая часть, которую нам нужно рассмотреть, - тройка Хоара из примеров два и три. Первая тройка верна, так как до выполнения предусловия операции x ^ 2 и x равно 5, то после выполнения операции постусловие (x больше 0) также будет выполнено (при условии правильной реализации целочисленной арифметики). В этом примере постусловие не является самым сильным, самое сильное возможное постусловие для этого предусловия - {x = 25}, а самое слабое - {x> 0}. Мы всегда можем создать новую тройку из существующей, сделав предусловие и постусловие слабее или сильнее.

  **4.2.	PRECONDITIONS AND POSTCONDITIONS FOR INHERITANCE**
  **4.3. Ковариантность и противоречивость**
    Основываясь на предыдущем примере, мы можем прийти к таким терминам, как ковариантный и контравариантный, при замене базового класса его подклассом входные значения для его методов должны быть контравариантными, то есть предусловие должно быть таким же или более слабым, а выходные значения должны быть ковариантными, то есть такими же или более сильными. Для лучшего понимания рассмотрим следующий пример: